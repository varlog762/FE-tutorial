/* 1. При создании функции в глобальной области видимости ее контекстом выполнения (this) будет либо window (если 'use strict' НЕ используется), либо undefined (если 'use strict' используется).
2. Контекстом выполнения метода всегда будет его объект.
3. this в конструкторах и классах - новый экземпляр объекта. */

// Call/Apply:

/* Методы call и apply делают одно и то же. Они позволяют вызывать функцию с заданным контекстом (значением this) и аргументами. */

// Call: 
/* Этот метод позволяет вызвать функцию, указав явно объект, который будет использоваться в качестве this внутри функции, а также аргументы функции передаются как отдельные аргументы в методе call. */

function sayHello(name) {
  console.log(`Hello, ${name}! I'm ${this.title}`);
}

const person1 = {
  title: 'Mr.',
};

sayHello.call(person1, 'John');

// Apply:
/* Этот метод похож на call, но аргументы передаются как массив. */
function sayHello(name) {
  console.log(`Hello, ${name}! I'm ${this.title}`);
}

const person2 = {
  title: 'Mr.',
};

sayHello.apply(person2, ['John']);

/* Эти методы полезны, когда у вас есть функция, которая использует this для доступа к данным объекта, и вы хотите вызвать эту функцию в контексте другого объекта. Методы call и apply позволяют контролировать значение this внутри функции, что часто используется для переиспользования функциональности между разными объектами или для избежания дублирования кода. */

// Bind:

/* Метод bind используется для создания новой функции, которая будет иметь определенное значение this, указанное при вызове bind. Это позволяет явно устанавливать контекст выполнения функции, независимо от того, как она была вызвана. */